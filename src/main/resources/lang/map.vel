include "lang/int.vel";

class Map[K, V]() {
    class Entry(K key, V val) {
        func setValue(V v) void {
            val = v
        };

        bool hasNext = false;
        Entry next;

        func setNext(Entry n) void {
            next = n;
            hasNext = true;
        };
    };

    int DEFAULT_CAPACITY = 16;
    array[Entry] buckets = new array[Entry](DEFAULT_CAPACITY);
    array[bool] occupied = new array[bool](DEFAULT_CAPACITY);
    int size = 0;

    int i = 0;
    while (i < DEFAULT_CAPACITY) {
        occupied[i] = false;
        i = i + 1;
    };

    func bucketIndex(K key) int {
        (key.hash % buckets.len).abs;
    };

    func empty() bool {
        size == 0;
    };

    func put(K key, V value) void {
        int bucketIndex = bucketIndex(key);
        Entry newEntry = new Entry(key, value);

        if (occupied[bucketIndex] == false) {
            buckets[bucketIndex] = newEntry;
            occupied[bucketIndex] = true;
            size = size + 1;
        } else {
            Entry current = buckets[bucketIndex];
            bool found = false;
            while (current.hasNext & found == false) {
                if (current.key == key) {
                    current.setValue(value);
                    found = true;
                } else {
                    current = current.next;
                };
            };
            if (found == false) {
                if (current.key == key) {
                    current.setValue(value);
                } else {
                    current.setNext(newEntry);
                    size = size + 1;
                };
            };
        };
    };

    func get(K key) ptr[V] {
        int bucketIndex = bucketIndex(key);

        if (occupied[bucketIndex]) {
            Entry current = buckets[bucketIndex];
            bool found = false;
            while (current.hasNext & found == false) {
                if (current.key == key) {
                    found = true;
                } else {
                    current = current.next;
                };
            };
            if (current.key == key) {
                new ptr[V](current.val);
            } else {
                null;
            };
        } else {
            null;
        };
    };
};
